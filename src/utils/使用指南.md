# Utils å·¥å…·ç±»ä½¿ç”¨æŒ‡å—

## ğŸ“š ç›®å½•
1. [Hash ç±» - å“ˆå¸Œå‡½æ•°](#hash-ç±»)
2. [Coding ç±» - åºåˆ—åŒ–/ååºåˆ—åŒ–](#coding-ç±»)
3. [Random ç±» - éšæœºæ•°ç”Ÿæˆ](#random-ç±»)

---

## ğŸ”‘ Hash ç±» - å“ˆå¸Œå‡½æ•°

### ä½œç”¨
å°†ä»»æ„æ•°æ®è½¬æ¢ä¸ºå›ºå®šå¤§å°çš„æ•´æ•°ï¼Œç”¨äºå¿«é€ŸæŸ¥æ‰¾å’Œå®šä½ã€‚

### æ ¸å¿ƒç”¨é€”
- **å“ˆå¸Œè¡¨**ï¼šå¿«é€ŸæŸ¥æ‰¾é”®å€¼å¯¹ï¼ˆO(1)æ—¶é—´å¤æ‚åº¦ï¼‰
- **æ•°æ®åˆ†ç‰‡**ï¼šå†³å®šæ•°æ®å­˜å‚¨åœ¨å“ªä¸ªæœåŠ¡å™¨
- **å¸ƒéš†è¿‡æ»¤å™¨**ï¼šå¿«é€Ÿåˆ¤æ–­æ•°æ®æ˜¯å¦å­˜åœ¨
- **ç¼“å­˜ç´¢å¼•**ï¼šå†…å­˜ä¸­çš„å¿«é€Ÿå®šä½

### å¸¸ç”¨æ–¹æ³•

```cpp
#include "utils/Hash.hpp"
using namespace utils;

// 1. è®¡ç®—å­—ç¬¦ä¸²çš„å“ˆå¸Œå€¼    
std::string key = "user:123";
uint32_t hash1 = Hash::HashString(key);
uint32_t hash2 = Hash::HashString(key, 0x12345678); // ä½¿ç”¨è‡ªå®šä¹‰ç§å­

// 2. è®¡ç®— Slice çš„å“ˆå¸Œå€¼ï¼ˆæ•°æ®åº“å¸¸ç”¨ï¼‰
Slice key_slice("user:123");
uint32_t hash3 = Hash::HashSlice(key_slice);

// 3. è®¡ç®—æ•´æ•°çš„å“ˆå¸Œå€¼
uint32_t id = 12345;
uint32_t hash4 = Hash::HashInt32(id);
uint64_t hash5 = Hash::HashInt64(1234567890ULL);

// 4. è®¡ç®—ä»»æ„å†…å­˜å—çš„å“ˆå¸Œå€¼
char data[] = {1, 2, 3, 4, 5};
uint32_t hash6 = Hash::ComputeHash(data, 5);

// 5. æŒ‡å®šç®—æ³•è®¡ç®—å“ˆå¸Œ
uint32_t hash7 = Hash::ComputeHashWith(
    Hash::MURMUR3_32,  // æˆ– FNV1A_32
    data, 5, 
    0x9747b28c
);

// 6. ç»„åˆå¤šä¸ªå€¼çš„å“ˆå¸Œï¼ˆç”¨äºå¤åˆé”®ï¼‰
uint32_t hash_key = Hash::HashString("user");
uint32_t hash_id = Hash::HashInt32(123);
uint32_t combined = Hash::CombineHash(hash_key, hash_id);
```

### å®é™…åº”ç”¨åœºæ™¯

```cpp
// åœºæ™¯1: åœ¨å“ˆå¸Œè¡¨ä¸­å­˜å‚¨é”®å€¼å¯¹
std::unordered_map<uint32_t, std::string> cache;
Slice key("user:123");
uint32_t hash = Hash::HashSlice(key);
cache[hash] = "Alice";

// åœºæ™¯2: æ•°æ®åˆ†ç‰‡ï¼ˆå†³å®šå­˜å‚¨åœ¨å“ªå°æœåŠ¡å™¨ï¼‰
int serverId = Hash::HashString("user:123") % numServers;
// serverId = 0, 1, 2... å†³å®šæ•°æ®å­˜åœ¨å“ªä¸ªæœåŠ¡å™¨

// åœºæ™¯3: å¸ƒéš†è¿‡æ»¤å™¨
bool exists = bloomFilter.check(
    Hash::HashSlice(key, seed1),
    Hash::HashSlice(key, seed2),
    Hash::HashSlice(key, seed3)
);
```

---

## ğŸ“¦ Coding ç±» - åºåˆ—åŒ–/ååºåˆ—åŒ–

### ä½œç”¨
å°†æ•°æ®è½¬æ¢ä¸ºå­—èŠ‚åºåˆ—ï¼ˆç¼–ç ï¼‰ï¼Œæˆ–ä»å­—èŠ‚åºåˆ—æ¢å¤æ•°æ®ï¼ˆè§£ç ï¼‰ã€‚ç”¨äºæ•°æ®æŒä¹…åŒ–å’Œç½‘ç»œä¼ è¾“ã€‚

### æ ¸å¿ƒç”¨é€”
- **ç£ç›˜å­˜å‚¨**ï¼šå°†é”®å€¼å¯¹å†™å…¥æ•°æ®é¡µ
- **WALæ—¥å¿—**ï¼šè®°å½•æ“ä½œåˆ°æ—¥å¿—æ–‡ä»¶
- **ç½‘ç»œä¼ è¾“**ï¼šæ‰“åŒ…æ•°æ®å‘é€ç»™å®¢æˆ·ç«¯
- **æ•°æ®æ¢å¤**ï¼šä»ç£ç›˜æˆ–æ—¥å¿—æ¢å¤æ•°æ®

### å¸¸ç”¨æ–¹æ³•

#### 1. å›ºå®šé•¿åº¦ç¼–ç ï¼ˆç”¨äºå®šé•¿ç»“æ„ï¼‰

```cpp
#include "utils/Coding.hpp"
using namespace utils;

// ç¼–ç 32ä½æ•´æ•°ï¼ˆ4å­—èŠ‚ï¼‰
char buf32[4];
uint32_t value = 12345;
Coding::EncodeFixed32(buf32, value);

// è§£ç 32ä½æ•´æ•°
uint32_t decoded = Coding::DecodeFixed32(buf32);

// ç¼–ç 64ä½æ•´æ•°ï¼ˆ8å­—èŠ‚ï¼‰
char buf64[8];
uint64_t big_value = 1234567890ULL;
Coding::EncodeFixed64(buf64, big_value);

// è§£ç 64ä½æ•´æ•°
uint64_t decoded_big = Coding::DecodeFixed64(buf64);
```

**ä½¿ç”¨åœºæ™¯**ï¼šé¡µå¤´ã€å…ƒæ•°æ®ç­‰å›ºå®šå¤§å°çš„ç»“æ„

#### 2. å˜é•¿ç¼–ç ï¼ˆVarintï¼ŒèŠ‚çœç©ºé—´ï¼‰

```cpp
// ç¼–ç å°æ•´æ•°ï¼ˆèŠ‚çœç©ºé—´ï¼‰
std::string buffer;
uint32_t length = 127;  // å°æ•°å­—
Coding::EncodeVarint32(&buffer, length);
// buffer ç°åœ¨åªæœ‰1å­—èŠ‚ï¼ˆè€Œä¸æ˜¯4å­—èŠ‚ï¼‰ï¼

uint32_t big_length = 300;
Coding::EncodeVarint32(&buffer, big_length);
// buffer ç°åœ¨æœ‰2å­—èŠ‚

// è§£ç 
Slice input(buffer);
uint32_t decoded_length;
if (Coding::GetVarint32(&input, &decoded_length)) {
    // è§£ç æˆåŠŸï¼Œinput æŒ‡é’ˆå·²ç§»åŠ¨åˆ°ä¸‹ä¸€ä¸ªä½ç½®
}
```

**ä½¿ç”¨åœºæ™¯**ï¼šå­˜å‚¨é•¿åº¦ä¿¡æ¯ã€è®¡æ•°ç­‰å°æ•´æ•°

#### 3. å¸¦é•¿åº¦å‰ç¼€çš„ Sliceï¼ˆæ•°æ®åº“æ ¸å¿ƒæ ¼å¼ï¼‰

```cpp
// ç¼–ç é”®å€¼å¯¹ï¼šæ ¼å¼ = [é•¿åº¦] + [æ•°æ®]
std::string buffer;
Slice key("user:123");
Slice value("Alice");

// ç¼–ç  key
Coding::PutLengthPrefixedSlice(&buffer, key);
// buffer: [8] + "user:123"

// ç¼–ç  value
Coding::PutLengthPrefixedSlice(&buffer, value);
// buffer: [8] + "user:123" + [5] + "Alice"

// è§£ç ï¼šä» buffer è¯»å–é”®å€¼å¯¹
Slice input(buffer);
Slice decoded_key, decoded_value;

// è¯»å– key
if (Coding::GetLengthPrefixedSlice(&input, &decoded_key)) {
    // decoded_key = "user:123"
    // input æŒ‡é’ˆå·²ç§»åŠ¨åˆ° value çš„ä½ç½®
}

// è¯»å– value
if (Coding::GetLengthPrefixedSlice(&input, &decoded_value)) {
    // decoded_value = "Alice"
}
```

**ä½¿ç”¨åœºæ™¯**ï¼š
- å°†é”®å€¼å¯¹å†™å…¥æ•°æ®é¡µ
- å°†å‘½ä»¤å†™å…¥WALæ—¥å¿—
- ç½‘ç»œåè®®ä¼ è¾“

#### 4. æµ®ç‚¹æ•°ç¼–ç ï¼ˆä¿ç•™æ¯”è¾ƒé¡ºåºï¼‰

```cpp
// ç¼–ç  doubleï¼ˆä¿è¯æŒ‰æ•´æ•°æ¯”è¾ƒæ—¶é¡ºåºæ­£ç¡®ï¼‰
char buf[8];
double price = 99.99;
Coding::EncodeDouble(buf, price);

// è§£ç 
double decoded_price = Coding::DecodeDouble(buf);
```

**ä½¿ç”¨åœºæ™¯**ï¼šéœ€è¦èŒƒå›´æŸ¥è¯¢çš„æµ®ç‚¹æ•°å­—æ®µ

### å®Œæ•´ç¤ºä¾‹ï¼šå­˜å‚¨å’Œè¯»å–é”®å€¼å¯¹

```cpp
// å­˜å‚¨é”®å€¼å¯¹åˆ°ç£ç›˜
void WriteKeyValue(const Slice& key, const Slice& value) {
    std::string buffer;
    
    // ç¼–ç æ ¼å¼ï¼š[keyé•¿åº¦] + key + [valueé•¿åº¦] + value
    Coding::PutLengthPrefixedSlice(&buffer, key);
    Coding::PutLengthPrefixedSlice(&buffer, value);
    
    // å†™å…¥ç£ç›˜
    WriteToDisk(buffer.data(), buffer.size());
}

// ä»ç£ç›˜è¯»å–é”®å€¼å¯¹
bool ReadKeyValue(Slice* input, Slice* key, Slice* value) {
    // è¯»å– key
    if (!Coding::GetLengthPrefixedSlice(input, key)) {
        return false;
    }
    
    // è¯»å– value
    if (!Coding::GetLengthPrefixedSlice(input, value)) {
        return false;
    }
    
    return true;
}
```

---

## ğŸ² Random ç±» - éšæœºæ•°ç”Ÿæˆ

### ä½œç”¨
ç”Ÿæˆé«˜è´¨é‡çš„ä¼ªéšæœºæ•°ï¼Œç”¨äºæµ‹è¯•ã€æ¨¡æ‹Ÿã€æ•°æ®ç”Ÿæˆç­‰åœºæ™¯ã€‚

### æ ¸å¿ƒç”¨é€”
- **å•å…ƒæµ‹è¯•**ï¼šç”Ÿæˆæµ‹è¯•æ•°æ®
- **æ€§èƒ½æµ‹è¯•**ï¼šç”Ÿæˆéšæœºé”®å€¼å¯¹è¿›è¡Œå‹åŠ›æµ‹è¯•
- **æ•°æ®æ¨¡æ‹Ÿ**ï¼šæ¨¡æ‹ŸçœŸå®åœºæ™¯çš„æ•°æ®åˆ†å¸ƒ
- **éšæœºé‡‡æ ·**ï¼šéšæœºé€‰æ‹©æ•°æ®

### å¸¸ç”¨æ–¹æ³•

```cpp
#include "utils/Random.hpp"
using namespace utils;

// 1. åˆ›å»ºéšæœºæ•°ç”Ÿæˆå™¨ï¼ˆå¯æŒ‡å®šç§å­ï¼‰
Random rng(12345);  // ç›¸åŒç§å­äº§ç”Ÿç›¸åŒåºåˆ—ï¼ˆä¿è¯æµ‹è¯•å¯é‡å¤ï¼‰

// 2. ç”Ÿæˆéšæœºæ•´æ•°
uint32_t num1 = rng.NextU32();        // [0, 2^32-1]
uint64_t num2 = rng.NextU64();        // [0, 2^64-1]
int32_t num3 = rng.Uniform(1, 100);   // [1, 100] ä¹‹é—´çš„éšæœºæ•°

// 3. ç”Ÿæˆéšæœºæµ®ç‚¹æ•°
double prob = rng.NextDouble();       // [0.0, 1.0)

// 4. ç”Ÿæˆéšæœºå­—èŠ‚åºåˆ—
char buffer[100];
rng.NextBytes(buffer, 100);

// 5. ç”Ÿæˆéšæœºå­—ç¬¦ä¸²
std::string str = rng.NextString(20);  // 20ä¸ªéšæœºå­—ç¬¦

// 6. ç”Ÿæˆæ•°æ®åº“é£æ ¼çš„éšæœºé”®
std::string key = rng.NextKey();       // "key_A3F2" æˆ– "user:123:name"

// 7. ç”Ÿæˆéšæœºå€¼ï¼ˆå¯å˜é•¿åº¦ï¼‰
std::string value = rng.NextValue(100); // å¹³å‡100å­—èŠ‚çš„éšæœºæ•°æ®

// 8. ç”Ÿæˆéšæœº Slice
Slice random_slice = rng.NextSlice(10, 50);  // 10-50å­—èŠ‚çš„éšæœºæ•°æ®
```

### å®é™…åº”ç”¨åœºæ™¯

#### åœºæ™¯1ï¼šå•å…ƒæµ‹è¯• - ç”Ÿæˆæµ‹è¯•æ•°æ®

```cpp
void TestHashTable() {
    Random rng(42);  // å›ºå®šç§å­ï¼Œä¿è¯æµ‹è¯•å¯é‡å¤
    
    // ç”Ÿæˆ1000ä¸ªéšæœºé”®å€¼å¯¹
    for (int i = 0; i < 1000; i++) {
        std::string key = rng.NextKey();
        std::string value = rng.NextValue(50);
        
        // æµ‹è¯•æ’å…¥
        hashTable.Insert(key, value);
    }
    
    // éªŒè¯
    assert(hashTable.Size() == 1000);
}
```

#### åœºæ™¯2ï¼šæ€§èƒ½æµ‹è¯• - å‹åŠ›æµ‹è¯•

```cpp
void BenchmarkRandomAccess() {
    Random rng;
    
    // ç”Ÿæˆéšæœºé”®è¿›è¡ŒæŸ¥æ‰¾
    for (int i = 0; i < 1000000; i++) {
        std::string key = rng.NextKey();
        auto value = database.Get(key);
    }
}
```

#### åœºæ™¯3ï¼šæ•°æ®æ¨¡æ‹Ÿ - æ¨¡æ‹ŸçœŸå®åœºæ™¯

```cpp
void SimulateUserData() {
    Random rng;
    
    for (int i = 0; i < 10000; i++) {
        // ç”Ÿæˆç”¨æˆ·IDï¼ˆ1-1000000ï¼‰
        int userId = rng.Uniform(1, 1000000);
        
        // ç”Ÿæˆç”¨æˆ·å
        std::string username = rng.NextString(10);
        
        // ç”Ÿæˆç”¨æˆ·æ•°æ®
        std::string userData = rng.NextValue(200);
        
        // å­˜å‚¨
        std::string key = "user:" + std::to_string(userId);
        database.Set(key, userData);
    }
}
```

#### åœºæ™¯4ï¼šå¹¶è¡Œæµ‹è¯• - åˆ’åˆ†éšæœºæ•°åºåˆ—

```cpp
void ParallelTest() {
    // çº¿ç¨‹1ï¼šä½¿ç”¨åºåˆ—çš„å‰åŠéƒ¨åˆ†
    Random rng1(42);
    
    // çº¿ç¨‹2ï¼šè·³è¿‡å‰åŠéƒ¨åˆ†ï¼Œä½¿ç”¨ååŠéƒ¨åˆ†
    Random rng2(42);
    rng2.Skip(500000);  // è·³è¿‡å‰50ä¸‡ä¸ªéšæœºæ•°
    
    // ä¸¤ä¸ªçº¿ç¨‹ä½¿ç”¨ä¸åŒçš„éšæœºæ•°åºåˆ—ï¼Œé¿å…å†²çª
}
```

---

## ğŸ¯ ä¸‰ä¸ªç±»çš„åä½œç¤ºä¾‹

```cpp
#include "utils/Hash.hpp"
#include "utils/Coding.hpp"
#include "utils/Random.hpp"

// å®Œæ•´çš„æ•°æ®åº“æ“ä½œç¤ºä¾‹
void DatabaseExample() {
    // 1. ç”Ÿæˆéšæœºæµ‹è¯•æ•°æ®
    Random rng(12345);
    std::string key = rng.NextKey();      // "key_A3F2"
    std::string value = rng.NextValue(100);
    
    // 2. è®¡ç®—é”®çš„å“ˆå¸Œå€¼ï¼ˆç”¨äºå“ˆå¸Œè¡¨ï¼‰
    uint32_t hash = Hash::HashString(key);
    
    // 3. åºåˆ—åŒ–é”®å€¼å¯¹ï¼ˆå‡†å¤‡å†™å…¥ç£ç›˜ï¼‰
    std::string buffer;
    Slice key_slice(key);
    Slice value_slice(value);
    Coding::PutLengthPrefixedSlice(&buffer, key_slice);
    Coding::PutLengthPrefixedSlice(&buffer, value_slice);
    
    // 4. å†™å…¥ç£ç›˜ï¼ˆè¿™é‡Œåªæ˜¯ç¤ºä¾‹ï¼‰
    WriteToDisk(buffer.data(), buffer.size());
    
    // 5. ä»ç£ç›˜è¯»å–
    std::string disk_data = ReadFromDisk();
    Slice input(disk_data);
    Slice decoded_key, decoded_value;
    Coding::GetLengthPrefixedSlice(&input, &decoded_key);
    Coding::GetLengthPrefixedSlice(&input, &decoded_value);
    
    // 6. éªŒè¯å“ˆå¸Œå€¼
    uint32_t hash2 = Hash::HashSlice(decoded_key);
    assert(hash == hash2);
}
```

---

## ğŸ“ æ€»ç»“

| ç±»å | ä¸»è¦ä½œç”¨ | ä½¿ç”¨åœºæ™¯ |
|------|---------|---------|
| **Hash** | å°†æ•°æ®è½¬æ¢ä¸ºæ•´æ•° | å“ˆå¸Œè¡¨ã€åˆ†ç‰‡ã€å¸ƒéš†è¿‡æ»¤å™¨ |
| **Coding** | æ•°æ®åºåˆ—åŒ–/ååºåˆ—åŒ– | ç£ç›˜å­˜å‚¨ã€WALæ—¥å¿—ã€ç½‘ç»œä¼ è¾“ |
| **Random** | ç”Ÿæˆéšæœºæ•° | å•å…ƒæµ‹è¯•ã€æ€§èƒ½æµ‹è¯•ã€æ•°æ®æ¨¡æ‹Ÿ |

è¿™ä¸‰ä¸ªå·¥å…·ç±»æ˜¯æ•°æ®åº“çš„åŸºç¡€è®¾æ–½ï¼Œå‡ ä¹æ‰€æœ‰çš„æ•°æ®åº“æ“ä½œéƒ½ä¼šç”¨åˆ°å®ƒä»¬ï¼

